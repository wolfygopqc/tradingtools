<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analyse de Marché avec TradingView</title>
    <style>
        html,
        body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: #0d1117;
            color: #e6edf3;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap');

        .site-header {
            padding: 15px 25px;
            background-color: #161b22;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 25px;
            border-bottom: 1px solid #21262d;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .site-header h1 {
            margin: 0;
            font-size: 1.5em;
            font-weight: 600;
            color: #58a6ff;
            white-space: nowrap;
        }
        
        .controls {
            display: flex;
            align-items: center;
            flex-grow: 1;
            max-width: 400px;
        }

        .controls input {
            flex-grow: 1;
            padding: 10px 15px;
            border: 1px solid #30363d;
            background-color: #0d1117;
            color: #e6edf3;
            border-radius: 6px 0 0 6px;
            font-size: 0.95em;
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }

        .controls input:focus {
            border-color: #58a6ff;
            box-shadow: 0 0 0 2px rgba(88, 166, 255, 0.3);
        }

        .controls button, .categories button {
            padding: 10px 18px;
            border: 1px solid #30363d;
            background-color: #238636;
            color: #e6edf3;
            cursor: pointer;
            font-size: 0.95em;
            font-weight: 600;
            transition: background-color 0.2s, border-color 0.2s, box-shadow 0.2s;
            outline: none;
            white-space: nowrap;
        }
        
        .controls button {
             border-radius: 0 6px 6px 0;
             border-left: none;
             background-color: #58a6ff;
        }
        
        .categories button {
            border-radius: 6px;
            background-color: #21262d;
            border-color: #30363d;
        }

        .categories {
            display: flex;
            gap: 10px;
            margin-left: auto;
        }

        .controls button:hover {
            background-color: #79c0ff;
            border-color: #79c0ff;
            box-shadow: 0 0 0 2px rgba(88, 166, 255, 0.5);
        }
        
        .categories button:hover {
            background-color: #30363d;
            border-color: #58a6ff;
        }

        #tv_chart_container {
            width: 100%;
            flex-grow: 1;
            border-top: 1px solid #21262d;
        }
    </style>

    <script type="text/javascript" src="charting_library/charting_library.standalone.js"></script>
</head>
<body>

    <header class="site-header">
        <h1>Analyseur de Marché</h1>
        <div class="controls">
            <input type="text" id="custom-symbol-input" placeholder="Ex: BTC/USD, AAPL...">
            <button id="load-symbol-button">Charger</button>
        </div>
        <div class="categories">
            <button class="category-button" data-symbol="AAPL">Actions</button>
            <button class="category-button" data-symbol="BTC/USD">Crypto</button>
            <button class="category-button" data-symbol="EUR/USD">Forex</button>
        </div>
    </header>

    <div id="tv_chart_container"></div>

    <script type="text/javascript">
        function getUrlParams() {
            const url = window.location.search;
            const params = new URLSearchParams(url);
            const urlParams = {};
            for (const [key, value] of params) {
                urlParams[key] = value;
            }
            return urlParams;
        }

        window.addEventListener('DOMContentLoaded', (event) => {
        // =================================================================================================
        // 1. CONFIGURATION & HELPERS
        // =================================================================================================

        // !!! IMPORTANT !!!
        // Remplacez "<api-key>" par votre propre clé API de CryptoCompare.
        const apiKey = "57f08ff3ab37cdb4b28bc26473a83f32dfb9f552c4eb54941a3cdb3472d0cb8d";

        const configurationData = {
            supported_resolutions: ['1', '5', '15', '60', '1D', '1W', '1M'],
            exchanges: [
                { value: 'Binance', name: 'Binance', desc: 'Binance' },
                { value: 'Coinbase', name: 'Coinbase', desc: 'Coinbase' },
                { value: 'Kraken', name: 'Kraken', desc: 'Kraken' },
            ],
            symbols_types: [{ name: 'crypto', value: 'crypto' }]
        };

        async function makeApiRequest(path) {
            try {
                const url = new URL(`https://min-api.cryptocompare.com/${path}`);
                url.searchParams.append('api_key', apiKey);
                const response = await fetch(url.toString());
                return response.json();
            } catch (error) {
                throw new Error(`CryptoCompare request error: ${error.status}`);
            }
        }

        function parseFullSymbol(fullSymbol) {
            const match = fullSymbol.match(/^(\w+):(\w+)\/(\w+)$/);
            if (!match) return null;
            return { exchange: match[1], fromSymbol: match[2], toSymbol: match[3] };
        }

        // =================================================================================================
        // 2. STREAMING (WEBSOCKET)
        // =================================================================================================

        const socket = new WebSocket(`wss://streamer.cryptocompare.com/v2?api_key=${apiKey}`);
        const channelToSubscription = new Map();

        socket.addEventListener('open', () => console.log('[socket] Connected'));
        socket.addEventListener('close', (reason) => console.log('[socket] Disconnected:', reason));
        socket.addEventListener('error', (error) => console.log('[socket] Error:', error));

        socket.addEventListener('message', (event) => {
            const data = JSON.parse(event.data);
            const { TYPE: eventType, M: exchange, FSYM: fromSymbol, TSYM: toSymbol, TS: tradeTime, P: tradePrice, Q: tradeVolume } = data;

            if (parseInt(eventType) !== 0) return;

            const channelString = `0~${exchange}~${fromSymbol}~${toSymbol}`;
            const subscriptionItem = channelToSubscription.get(channelString);

            if (subscriptionItem === undefined) return;

            const lastBar = subscriptionItem.lastBar;
            const nextBarTime = getNextBarTime(lastBar.time, subscriptionItem.resolution);

            let bar;
            if (tradeTime * 1000 >= nextBarTime) {
                bar = { time: nextBarTime, open: tradePrice, high: tradePrice, low: tradePrice, close: tradePrice, volume: tradeVolume };
            } else {
                bar = { ...lastBar, high: Math.max(lastBar.high, tradePrice), low: Math.min(lastBar.low, tradePrice), close: tradePrice, volume: (lastBar.volume || 0) + tradeVolume };
            }
            subscriptionItem.lastBar = bar;
            subscriptionItem.handlers.forEach((handler) => handler.callback(bar));
        });

        function getNextBarTime(barTime, resolution) {
            const date = new Date(barTime);
            if (resolution === '1D') {
                date.setUTCDate(date.getUTCDate() + 1);
                date.setUTCHours(0, 0, 0, 0);
            } else {
                const interval = parseInt(resolution);
                date.setUTCMinutes(date.getUTCMinutes() + interval);
            }
            return date.getTime();
        }

        function subscribeOnStream(symbolInfo, resolution, onRealtimeCallback, subscriberUID, onResetCacheNeededCallback, lastBar) {
            const parsedSymbol = parseFullSymbol(symbolInfo.ticker);
            const channelString = `0~${parsedSymbol.exchange}~${parsedSymbol.fromSymbol}~${parsedSymbol.toSymbol}`;
            const handler = { id: subscriberUID, callback: onRealtimeCallback };

            let subscriptionItem = channelToSubscription.get(channelString);
            if (subscriptionItem) {
                subscriptionItem.handlers.push(handler);
                return;
            }

            subscriptionItem = { subscriberUID, resolution, lastBar, handlers: [handler] };
            channelToSubscription.set(channelString, subscriptionItem);

            const subRequest = { action: 'SubAdd', subs: [channelString] };
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(subRequest));
            }
        }

        function unsubscribeFromStream(subscriberUID) {
            for (const channelString of channelToSubscription.keys()) {
                const sub = channelToSubscription.get(channelString);
                const handlerIndex = sub.handlers.findIndex(h => h.id === subscriberUID);

                if (handlerIndex !== -1) {
                    sub.handlers.splice(handlerIndex, 1);
                    if (sub.handlers.length === 0) {
                        const subRequest = { action: 'SubRemove', subs: [channelString] };
                        socket.send(JSON.stringify(subRequest));
                        channelToSubscription.delete(channelString);
                        break;
                    }
                }
            }
        }

        // =================================================================================================
        // 3. DATAFEED IMPLEMENTATION
        // =================================================================================================

        const lastBarsCache = new Map();

        const customDatafeed = {
            onReady: (callback) => {
                console.log('[onReady]: Method call');
                setTimeout(() => callback(configurationData));
            },

            searchSymbols: async (userInput, exchange, symbolType, onResultReadyCallback) => {
                console.log('[searchSymbols]: Method call');
                const allSymbols = await getAllSymbols();
                const newSymbols = allSymbols.filter(symbol => {
                    const isExchangeValid = exchange === '' || symbol.exchange === exchange;
                    const isFullSymbolContainsInput = symbol.ticker.toLowerCase().indexOf(userInput.toLowerCase()) !== -1;
                    return isExchangeValid && isFullSymbolContainsInput;
                });
                onResultReadyCallback(newSymbols);
            },

            resolveSymbol: async (symbolName, onSymbolResolvedCallback, onResolveErrorCallback) => {
                console.log('[resolveSymbol]: Method call', symbolName);
                const allSymbols = await getAllSymbols();
                const symbolItem = allSymbols.find(({ ticker }) => ticker === symbolName);

                if (!symbolItem) {
                    console.log('[resolveSymbol]: Cannot resolve symbol', symbolName);
                    onResolveErrorCallback("unknown_symbol");
                    return;
                }

                const symbolInfo = {
                    ticker: symbolItem.ticker, name: symbolItem.symbol, description: symbolItem.description,
                    type: symbolItem.type, exchange: symbolItem.exchange, listed_exchange: symbolItem.exchange,
                    session: '24x7', timezone: 'Etc/UTC', minmov: 1, pricescale: 100000000,
                    has_intraday: true, intraday_multipliers: ['1', '5', '15', '60'], has_daily: true,
                    supported_resolutions: configurationData.supported_resolutions, volume_precision: 8, data_status: 'streaming',
                };
                onSymbolResolvedCallback(symbolInfo);
            },

            getBars: async (symbolInfo, resolution, periodParams, onHistoryCallback, onErrorCallback) => {
                const { from, to, firstDataRequest } = periodParams;
                console.log('[getBars]: Method call', symbolInfo, resolution, from, to);
                const parsedSymbol = parseFullSymbol(symbolInfo.ticker);

                const urlParameters = {
                    e: parsedSymbol.exchange,
                    fsym: parsedSymbol.fromSymbol,
                    tsym: parsedSymbol.toSymbol,
                    toTs: to,
                    limit: 2000,
                };
                const query = Object.keys(urlParameters).map(name => `${name}=${encodeURIComponent(urlParameters[name])}`).join('&');
                const endpoint = resolution === '1D' ? 'histoday' : (resolution.includes('W') || resolution.includes('M')) ? 'histoday' : 'histominute';

                try {
                    const data = await makeApiRequest(`data/v2/${endpoint}?${query}`);
                    if ((data.Response && data.Response === 'Error') || data.Data.Data.length === 0) {
                        onHistoryCallback([], { noData: true });
                        return;
                    }
                    let bars = [];
                    data.Data.Data.forEach(bar => {
                        if (bar.time >= from && bar.time < to) {
                            bars.push({ time: bar.time * 1000, low: bar.low, high: bar.high, open: bar.open, close: bar.close, volume: bar.volumefrom });
                        }
                    });
                    if (firstDataRequest) {
                        lastBarsCache.set(symbolInfo.ticker, { ...bars[bars.length - 1] });
                    }
                    console.log(`[getBars]: returned ${bars.length} bar(s)`);
                    onHistoryCallback(bars, { noData: false });
                } catch (error) {
                    console.log('[getBars]: Get error', error);
                    onErrorCallback(error);
                }
            },

            subscribeBars: (symbolInfo, resolution, onRealtimeCallback, subscriberUID, onResetCacheNeededCallback) => {
                console.log('[subscribeBars]: Method call with subscriberUID:', subscriberUID);
                subscribeOnStream(symbolInfo, resolution, onRealtimeCallback, subscriberUID, onResetCacheNeededCallback, lastBarsCache.get(symbolInfo.ticker));
            },

            unsubscribeBars: (subscriberUID) => {
                console.log('[unsubscribeBars]: Method call with subscriberUID:', subscriberUID);
                unsubscribeFromStream(subscriberUID);
            },
        };

        async function getAllSymbols() {
            const data = await makeApiRequest('data/v3/all/exchanges');
            let allSymbols = [];
            const generateSymbol = (exchange, fromSymbol, toSymbol) => ({ short: `${fromSymbol}/${toSymbol}`, full: `${exchange}:${fromSymbol}/${toSymbol}` });

            for (const exchange of configurationData.exchanges) {
                if (data.Data[exchange.value]) {
                    const pairs = data.Data[exchange.value].pairs;
                    for (const leftPairPart of Object.keys(pairs)) {
                        const symbols = pairs[leftPairPart].map(rightPairPart => {
                            const symbol = generateSymbol(exchange.value, leftPairPart, rightPairPart);
                            return { symbol: symbol.short, ticker: symbol.full, description: symbol.short, exchange: exchange.value, type: 'crypto' };
                        });
                        allSymbols = [...allSymbols, ...symbols];
                    }
                }
            }
            return allSymbols;
        }

        // =================================================================================================
        // 4. WIDGET INITIALIZATION
        // =================================================================================================

        const urlParams = getUrlParams();
        const language = urlParams.lang || "fr";

        const tvWidget = new TradingView.widget({
            symbol: 'Binance:BTC/USDT',
            interval: '60',
            container: 'tv_chart_container',
            datafeed: customDatafeed,
            library_path: 'charting_library/',
            locale: language,
            fullscreen: false,
            theme: "dark",
            disabled_features: ["use_localstorage_for_settings", "popup_hints", "header_compare"],
            enabled_features: ["study_templates", "side_toolbar_in_fullscreen_mode", "items_favoriting", "hide_left_toolbar_by_default"],
            overrides: {
                "paneProperties.background": "#0d1117",
                "paneProperties.vertGridProperties.color": "#21262d",
                "paneProperties.horzGridProperties.color": "#21262d",
                "symbolWatermarkProperties.transparency": 90,
                "scalesProperties.textColor": "#e6edf3",
                "mainSeriesProperties.candleStyle.upColor": "#26a69a",
                "mainSeriesProperties.candleStyle.downColor": "#ef5350",
                "mainSeriesProperties.candleStyle.borderUpColor": "#26a69a",
                "mainSeriesProperties.candleStyle.borderDownColor": "#ef5350",
                "mainSeriesProperties.candleStyle.wickUpColor": "#26a69a",
                "mainSeriesProperties.candleStyle.wickDownColor": "#ef5350",
            },
        });

        tvWidget.onChartReady(() => {
            console.log("Le graphique est prêt !");
            const chart = tvWidget.activeChart();
            chart.onIntervalChanged().subscribe(null, () => {
                console.log('Interval changed. Cache could be reset here if needed.');
            });
        });

        // --- Logique pour les contrôles personnalisés ---
        const loadSymbolButton = document.getElementById('load-symbol-button');
        const customSymbolInput = document.getElementById('custom-symbol-input');
        const setSymbol = (symbol) => {
            if (tvWidget && tvWidget.chart()) {
                // Pour un datafeed personnalisé, il faut le ticker complet comme "Exchange:FROM/TO"
                // On essaie de trouver un symbole correspondant sur un exchange par défaut si non spécifié.
                let fullSymbol = symbol;
                if (!symbol.includes(':')) {
                    fullSymbol = `Binance:${symbol}`; // Binance par défaut
                }
                tvWidget.chart().setSymbol(fullSymbol, () => console.log("Symbole changé pour :", fullSymbol));
            }
        };
        loadSymbolButton.addEventListener('click', () => { if (customSymbolInput.value) setSymbol(customSymbolInput.value.toUpperCase()); });
        customSymbolInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && customSymbolInput.value) setSymbol(customSymbolInput.value.toUpperCase()); });
        document.querySelectorAll('.category-button').forEach(button => {
            button.addEventListener('click', () => {
                const symbol = button.getAttribute('data-symbol');
                // On ajuste les symboles par défaut pour correspondre au nouveau format du datafeed
                const cryptoSymbols = { "AAPL": "Coinbase:BTC/USD", "BTC/USD": "Binance:BTC/USDT", "EUR/USD": "Kraken:EUR/USD" };
                tvWidget.chart().setSymbol(cryptoSymbols[symbol] || "Binance:ETH/USDT");
            });
        });
    });
    </script>

</body>
</html>
